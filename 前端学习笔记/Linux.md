# Linux 命令

## 文件查找

- whereis：显示命令路径以及命令相关的帮助文件路径

  -b:查找可执行文件，-m:查找帮助文件，-s:查找源代码文件

  ```
  whereis pwd #查找pwd命令的相关文件
  whereis -m pwd #查找pwd命令的帮助文件
  ```

- locate：从 linux 内置的索引数据库/var/lib/mlocate/mlocate.db 查找文件，查询速度超快

  - -i：忽略大小写
  - -l：仅输出几行的意思，例如输出 5 行则是-l 5；
  - -r :后面可接正则表达式的显示方式
  - -c：不输出文件名，仅计算找到的文件数量；

  ```
  locate pwd # 查找pwd命令相关的所有文件
  locate /etc/sh # 查找etc目录下以sh开头的文件
  locate -c /etc/sh #查找etc目录下以sh开头的文件数
  locate -l 4 passwd # 是输出前4行
  ```

- find:从文件系统中进行搜索，默认从根目录搜索，速度很慢，一般是搜索指定目录下符合条件的文件。

  - -name：按照名称查找
  - -type：安装文件类型查找（“f”标识文件，"d"表示文件夹）
  - -size：根据大小查找
  - -perm：根据权限查找
  - -mtime：根据修改时间查找
  - -atime：根据访问时间查找

  ```
  find ./ -name test.sh # 查看当前目录下名为test.sh的文件
  find ./ -name '*.sh' # 查找当前目录下后缀为sh的文件。
  find /etc -type f # 查找etc目录下的所有文件
  find /etc -type d # 查找etc目录下的所有文件夹
  find /home -size 10M #  查找home目录下等于10M的文件
  find /home -size +10M # 查找home目录下大于10M的文件
  find /home -size +5M -size -10M # 查找home目录下大于5M小于10M的文件
  find /home -perm 777 # 查找home目录下权限为777的文件或目录
  find / -mtime -3 #查找3天内修改过的文件
  find / -atime -3 #查找3天内访问过的文件
  ```

总结，这三个命令都是查找文件的，`whereis`及`locate`都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找真实的文件，所以资源消耗比较大，速度慢。查找一般文件优先使用`whereis`和`locate`，两个都搜索不到或者需要使用更多条件搜索再使用 find。

## 内容查找

- grep：可以从文本文件或者管道数据流中筛选匹配的行或者数据。可以使用字符串或者正则表达式匹配。

  - -v：显示不匹配的文本（排查符合的行）
  - -i：不区分大小写
  - -n：显示匹配行及行号
  - -c：显示匹配的行数
  - -o：只输出匹配的内容
  - -w：精确匹配过滤的字符串

  ```
  grep "cpu" cpuinfo # 输出文件中包含cpu的行（加个| wc -l就可以统计行数）
  grep -v "cpu" cpuinfo # 输出文件中不包含cpu的行
  grep -n "cpu" cpuinfo # 输出文件中包含cpu的行及行号
  grep -c "cpu" cpuinfo # 输出文件中匹配cpu字符串的数量
  grep -o "cpu" cpuinfo # 只输出匹配的内容cpu
  grep -w "cpu" cpuinfo # 只匹配cpu这个单词的行
  ```

- vim:如果要查找某个字符串的位置，也可以使用 vi/vim 命令的搜索功能：

  1、命令模式下输入“/字符串”，例如“/cpu”

  2、输入“n”查找下一个，输入"N"查找上一个。

  ​

## 日志查找

- 查找关键日志的行号

  ```
  cat -n test.log | grep "debug"
  ```

- 查询 92 行之后的日志

  ```
  cat -n test.log | tail -n +92  //-92为显示末尾92行
  ```

- 查询前 20 行的日志

  ```
  cat -n test.log | head -n +20
  ```

- 实时监控后 100 行日志

  ```
  tail -100f test.log
  ```

- 查找日志中指定内容

  ```
  1.vim test.log
  2.进入命令模式，输入"/"+查找的内容,按enter键查找
  3.然后按"n"查找下一个
  4.用esc退出查找模式，用：wq！或者：q！保存退出或者不保存退出
  ```

## 查看端口

- 查看 3306 端口的使用情况

  ```
  netstat -anp | grep 3306 查看3306端口的使用情况
  ```

- 查看一个服务有几个端口，比如 Mysqld

  ```
  ps -ef | grep mysqld
  ```

- 查看 3306 端口的连接数量

  ```
  netstat -pnt | grep 3306 | wc
  ```

- 用于查看端口对应的应用程序(ps 和 netstat 的结合)

  ```
  lsof -i : 8000
  ```

- 仅显示 TCP 连接

  ```
  lsof -i tcp
  ```

  ​

  ​

## 抓包

## 查看进程

- 查看进程（a 代表 all，x 会显示没有控制终端的进程）

  ```
  ps -ax | less
  ```

- 按照 cpu 或内存用量来筛选

  ```
  ps -aux | less
  ```

- 按照 cpu 使用率来升序排序

  ```
  ps -aux --sort -pcpu | less
  ```

- 查找名称 getty 的进程

  ```
  ps -C getty
  ```

- 进程树

  ```
  pstree
  ```

  ​

  ## 查看内存的使用情况

- 展示内存

  ```
  free -h
  ```

- 查看/proc/meminfo 文件

  ```
  cat /proc/meminfo
  ```

- 对内存情况进行统计

  ```
  vmstat -s
  ```

- 输入 top 命令：一般用来查看进程的 cpu 和内存的使用情况，当然也会报告内存总量，以及内存使用情况，使用用来监控物理内存的使用情况

  ```
  top
  ```

## 网络相关

- 查看网络路由跳转

  ```
  traceroute www.baidu.com  (ping)
  ```

- 查看路由表

  ```
  route -n  (netstat -rn)
  ```

- 删除网络网关

  ```
  route del default gw 192.168.0.1
  ```

- 添加网络网关

  ```
  route add default gw 192.168.0.1
  ```

- 查看 ip

  ```
  ipconfig
  ```

  ​

  ## linux 连接外部

- linux 连接 redis

  ```
  1、进入redis文件下的bin目录下：cd /usr/local/redis/bin/
  2、执行 ./redis-cli
  ```

- linux 连接 mysql

  ```
  1、进入数据库：mysql -u root -p
  2、启动mysql服务： service mysql start
  ```

  ​

# 操作系统

## 一、操作系统基础

### 1.1 什么是操作系统？

👨‍💻**面试官** ： 先来个简单问题吧！**什么是操作系统？**

🙋 **我** ：我通过以下四点向您介绍一下什么是操作系统吧！

1. **操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。**
2. **操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。** 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
3. **操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
4. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

![Kernel_Layout](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png)

### 1.2 用户态和内核态

👨‍💻**面试官** ：**什么是系统调用呢？** 能不能详细介绍一下。

🙋 **我** ：介绍系统调用之前，我们先来了解一下用户态和内核态。

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

1. **用户态**(user mode) : 只能执行那些受限级别的代码。如果需要调用特权代码需要进行内核态切换。
2. **内核态**(kernel mode):可以执行一切特权代码，内核态级别的资源有关的操作有文件管理、进程控制、内存管理等。

这种概念存在的意义就是为了进行权限保护，限定用户的程序不能乱搞操作系统。在 intel cpu 的设计下操作系统分为 4 个 ring，分别是 ring0，1，2，3。用户态的程序工作在 3，内核态的程序处于 0。

**用户态切换到内核态的 3 种方式：**

- **系统调用** (本质是内中断)

用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 fork()方法，实际上就是执行了一个创建新进程的系统调用（read、write 也是）。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 int 80h 中断。

> 这些系统调用按功能大致可分为如下几类：
>
> - 设备管理。完成设备的请求或释放，以及设备启动等功能。
> - 文件管理。完成文件的读、写、创建及删除等功能。
> - 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
> - 进程通信。完成进程之间的消息传递或信号传递等功能。
> - 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

- **异常** (是内中断)

当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

- **外围设备的中断** (是外中断)

当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

> 硬中断的处理流程如下：
>
> - 1、**外设** 将中断请求发送给中断控制器；
> - 2、**中断控制器** 根据中断优先级，有序地将中断传递给 CPU；
> - 3、**CPU** 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；
> - 4、**CPU** 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；
> - 5、**CPU** 恢复寄存器中的数值，返回原程序流停止位置继续执行。

这 3 种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。CPU 是怎么知道目前所处于的状态呢？这就要考 PSW (Program Status Word)寄存器里的值来辨别。这三种状态切换本质都是走了中断处理流程。至于从内核态切换到用户态则是通过设置 PSW 字段来进行转换。

#### 系统调用的实现

> [系统调用的实现](https://juejin.cn/post/6963638993913118750)

- 调用用户接口函数，用户接口封装的是系统调用的库函数

  ```
  int getpid(){
      return _syscall0(SYS_getpid);
  }
  ```

- 处理中断前要先保存上下文，然后库函数传入系统调用号、参数，以及 int 80h，然后执行 int 指令触发软中断，中断向量号为 Ox80

  （int n 就相当于发生了一个 n 号中断，属于软中断）

- cpu 被软中断打断后，执行中断向量对应的中断处理函数，这时便进入了内核态

- 进入内核态后，系统调用处理函数根据传递的系统调用号来调用对应的系统调用服务例程，这期间会保存所有的寄存器

- 最后就是将执行结果返回，将当前寄存器 eax 的值保存到上下文里面的 eax 处即可

### 1.3 文件描述符

> Linux 平台万物皆文件:
>
> "Everything is a File" and Types of Files in Linux!

**文件描述符**（file descriptor，简称 fd）在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。

在 Linux 中，内核将所有的外部设备都当做一个文件来进行操作，而对一个文件的读写操作会调用内核提供的系统命令，返回一个 fd，对一个 socket 的读写也会有相应的描述符，称为 socketfd（socket 描述符），实际上描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性)。

### 1.4 Unix 网络编程模型

> [Unix 网络模型](https://juejin.cn/post/7076364933184618526)

根据 UNIX 网络编程对 IO 模型的分类，UNIX 提供了以下 5 种 IO 模型。

#### 阻塞式 IO（Blocking IO）

在阻塞式 IO 下，进程空间中调用 recvfrom 库函数进行系统调用，这期间应用进程会一直阻塞，直到系统调用返回数据包且被复制到应用进程的缓存区中或者发生错误。阻塞 I/O 分为如下两个阶段：

- 阶段 1：等待数据就绪。网络 I/O 的情况就是等待远端数据陆续抵达；磁盘 I/O 的情况就是等待磁盘数据从磁盘上读取到内核态内存中。
- 阶段 2：数据拷贝。出于系统安全，用户态的程序没有权限直接读取内核态内存，因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。

#### 非阻塞 I/O（NIO）

在非阻塞 I/O 下，I/O 操作函数将不断进行系统调用，当请求的 I/O 无法完成时，不会将线程阻塞，而是返回一个错误码，进程在返回之后，可以干点别的事情，然后再继续发起请求，这样进程就不会阻塞。这种循环直到 I/O 操作函数等到了数据，从内核拷贝到用户空间为止。

但是这种方法需要不断地轮询、重复请求，消耗了大量的 CPU 的资源。

#### IO 多路复用

IO 多路复用 IO 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，占用 cpu。多路是指网络连接，复用指的是同一个线程。

服务器端采用单线程通过 select/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send，使其能支持更多的并发连接请求。

##### IO 多路复用的三种方式

- select

  ```c
  // 返回值：做好准备的文件描述符的个数，超时为 0，错误为-1.
  #include <sys/select.h>
  #include <sys/time.h>

  #define FD_SETSIZE 1024
  #define NFDBITS (8 * sizeof(unsigned long))
  #define __FDSET_LONGS (FD_SETSIZE/NFDBITS)

  // 数据结构 (bitmap)
  typedef struct {
      unsigned long fds_bits[__FDSET_LONGS];
  } fd_set;

   // API
  int select(
    int max_fd,
    fd_set *readset,
    fd_set *writeset,
    fd_set *exceptset,
    struct timeval *timeout
    )   // 返回值就绪描述符的数目

    FD_ZERO(int fd, fd_set* fds)   // 清空集合
    FD_SET(int fd, fd_set* fds)    // 将给定的描述符加入集合
    FD_ISSET(int fd, fd_set* fds)  // 判断指定描述符是否在集合中
    FD_CLR(int fd, fd_set* fds)    // 将给定的描述符从文件中删除
  ```

  通过 select（）方法传递参数，参数有所关心的文件描述符和可以等待的最长时间。并传入数组拷贝到内存空间。调用后 select 函数后用户进程会阻塞，内核会遍历所有的 fd，没有发现就绪设备就挂起当前进程，直到有 fd 就绪（有数据 可读、可写、或者有 except）或者主动超时。被唤醒后内核通过遍历得到已经就绪的描述符的个数，通过返回值告诉用户态。**但是不会告诉用户态具体是哪些事件就绪，需要用户态自己去事件集一个一个遍历判断。**有了这些返回信息，我们可以调用合适的 I/O 函数（比如 read 或 write)，并且这些函数不会再阻塞，这样的话**用户可以在一个线程内同时处理多个 socket 的 IO 请求**。

  **select 具有 O(n) 的无差别轮询复杂度**，高并发时效率较低。 每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大，而且单个进程所打开的 FD 是有限制的，通过 FD_SETSIZE 设置，默认 1024。

- POll

  poll 本质和 select 没有区别，只是 poll 是基于链表来存储的，所有它没有最大连接数的限制。poll 还有一个特点是采用了水平触发的通知策略，文件描述符就绪了会一直进行通知。

  - **水平触发**

    当关系描述符关联的读内核缓存区非空，有数据读取，就一直发出可读信号进行通知。当关系描述符关联的写内核缓存区不满，有空间写入，就一直发出可写信号进行通知。也就是 fd 变为就绪态会一直通知。

  - **边缘触发**

    和水平触发不同的是，边缘触发只有当读内核缓存区由空变为非空时才通知一次，或者是写内核缓存区由满变不满时通知一次，也就是**只在 fd 变为就绪态的时候通知一次**。

- epoll

  第一步，创建一个 epoll 句柄 int epoll_create(int size);第二步，向内核添加、修改或删除要监控的文件描述符。int epoll_ctl( int epfd, int op, int fd, struct epoll_event *event);第三步，类似发起了 select() 调用 int epoll_wait( int epfd, struct epoll_event *events, int max events, int timeout);

  epoll 是 select 和 poll 的增强版，使用了**事件**的触发机制。在 epoll 中，内核保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。而且也不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。每当有 fd 就绪，就将就绪 fd 放进就绪链表里面返回，时间复杂度为 O（1），也就是说仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。使用 epoll 优点是只关注“活跃的”文件描述符，只有活跃的文件描述符才能进行回调返回到用户态，大大提高了效率

## 二 进程和线程

### 2.1 进程和线程的区别

👨‍💻**面试官**: 好的！我明白了！那你再说一下： **进程和线程的区别**。

🙋 **我：** 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！

![img](https://oscimg.oschina.net/oscnet/up-cd8ac705f6f004c01e0a1312f1599430ba5.png)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

### 2.2 进程有哪几种状态?

👨‍💻**面试官** ： 那你再说说**进程有哪几种状态?**

🙋 **我** ：我们一般把进程大致分为 5 种状态，这一点和线程很像！

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

> 订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。

![process-state](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png)

### 2.3 进程间的通信方式

👨‍💻**面试官** ：**进程间的通信常见的的有哪几种方式呢?**

🙋 **我** ：大概有 7 种常见的进程间的通信方式。

> 下面这部分总结参考了:[《进程间通信 IPC (InterProcess Communication)》open in new window](https://www.jianshu.com/p/c1015f5ffa74) 这篇文章，推荐阅读，总结的非常不错。

1. **管道/匿名管道(Pipes)** ：匿名管道是特殊类型的文件，用于具有亲缘关系的父子进程间或者兄弟进程之间的通信，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止。

4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与存在于内存文件中的匿名管道，存在于实际的磁盘介质或者文件系统中的有名管道不同的是，消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。**

5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。因为只需进行 2 次数据的拷贝，而且会一直保持共享区域，所以说这是效率最高的进程间通信方式。

7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

   ​

#### 共享内存的实现

> [实现原理](https://juejin.cn/post/6844903855235268615)

共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现。现代的 cpu 寻址使用的是虚拟寻址，使用虚拟寻址，cpu 需要将虚拟地址翻译成物理地址，就可以访问到真实的物理内存。而虚拟内存为每个进程提供了一个连续完整的私有内存空间，不同进程的私有空间对应的虚拟地址映射到同一个物理内存地址就能实现内存的共享。

而实现进程虚拟内存地址与内存物理地址的映射采用的是 mmap 方法：

```
 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面(到对应的文件磁盘上),这样就完成了对文件的操作而不必再调用 read,write 等系统调用函数。

mmap 适合对用一块内存频繁读写的情况，因为可以减少内存的拷贝次数，比如在 read 调用时，一个完整的流程是操作系统读磁盘文件到页缓存，再从页缓存将数据拷贝到 read 传递的 buffer 里，而如果使用 mmap 之后，操作系统只需要将磁盘读到页缓存，然后用户就可以直接通过指针的方式操作 mmap 映射的内存，减少了从内核态到用户态的数据拷贝次数，减少了系统调用的次数。

### 2.4 线程间的同步的方式

👨‍💻**面试官** ：**那线程间的同步的方式有哪些呢?**

🙋 **我** ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 2.5 进程的调度算法

👨‍💻**面试官** ：**你知道操作系统中进程的调度算法有哪些吗?**

🙋 **我** ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！

为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

### 2.6 什么是死锁

👨‍💻**面试官** ：**你知道什么是死锁吗?**

🙋 **我** ：死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

### 2.7 死锁的四个条件

👨‍💻**面试官** ：**产生死锁的四个必要条件是什么?**

🙋 **我** ：如果系统中以下四个条件同时成立，那么就能引起死锁：

- **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
- **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
- **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

注意，只有四个条件同时成立时，死锁才会出现。

### 2.8 解决死锁的方法

解决死锁的方法可以从多个角度去分析，一般的情况下，有**预防，避免，检测和解除四种**。

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免**则是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**
- **检测**是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。

#### 死锁的预防

死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。

破坏第一个条件 **互斥条件**：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 **往往是不能同时访问的** ，所以这种做法在大多数的场合是行不通的。

破坏第三个条件 **非抢占** ：也就是说可以采用 **剥夺式调度算法**，但剥夺式调度方法目前一般仅适用于 **主存资源** 和 **处理器资源** 的分配，并不适用于所以的资源，会导致 **资源利用率下降**。

所以一般比较实用的 **预防死锁的方法**，是通过考虑破坏第二个条件和第四个条件。

**1、静态分配策略**

静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。

静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 **几乎不用的资源而使其他需要该资源的进程产生等待** 的情况。

**2、层次分配策略**

层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。

#### 死锁的避免

上面提到的 **破坏** 死锁产生的四个必要条件之一就可以成功 **预防系统发生死锁** ，但是会导致 **低效的进程运行** 和 **资源使用率** 。而死锁的避免相反，它的角度是允许系统中**同时存在四个必要条件** ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 **明智和合理的选择** ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。

我们将系统的状态分为 **安全状态** 和 **不安全状态** ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。

> 如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。

那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 **避免死锁算法** 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，**银行家算法** 通过先 **试探** 分配给该进程资源，然后通过 **安全性算法** 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 **真的分配资源给该进程**。

银行家算法详情可见：[《一句话+一张图说清楚——银行家算法》open in new window](https://blog.csdn.net/qq_33414271/article/details/80245715) 。

操作系统教程树中讲述的银行家算法也比较清晰，可以一看.

死锁的避免(银行家算法)改善解决了 **资源使用率低的问题** ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 **安全性检查** ，需要花费较多的时间。

#### 死锁的检测

对资源的分配加以限制可以 **预防和避免** 死锁的发生，但是都不利于各进程对系统资源的**充分共享**。解决死锁问题的另一条途径是 **死锁检测和解除** (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 **乐观锁** ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 **死锁的预防和避免** 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。

这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 **定时地运行一个 “死锁检测”** 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。

##### 进程-资源分配图

操作系统中的每一刻时刻的**系统状态**都可以用**进程-资源分配图**来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于**检测系统是否处于死锁状态**。

用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 **有向边** 来表示**进程申请资源和资源被分配的情况**。

图中 2-21 是**进程-资源分配图**的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 **占有和等待资源的环路** ，导致一组进程永远处于等待资源的状态，发生了 **死锁**。

![进程-资源分配图](https://javaguide.cn/assets/%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.31e353df.jpg)

进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。

##### 死锁检测步骤

知道了死锁检测的原理，我们可以利用下列步骤编写一个 **死锁检测** 程序，检测系统是否产生了死锁。

1. 如果进程-资源分配图中无环路，则此时系统没有发生死锁
2. 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。
3. 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 **既不阻塞又非独立的进程** ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 **消除所有的边** ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 **拓扑排序**)

#### 死锁的解除

当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：

1. **立即结束所有进程的执行，重新启动操作系统** ：这种方法简单，但以前所在的工作全部作废，损失很大。
2. **撤销涉及死锁的所有进程，解除死锁后继续运行** ：这种方法能彻底打破**死锁的循环等待**条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。
3. **逐个撤销涉及死锁的进程，回收其资源直至死锁解除。**
4. **抢占资源** ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。

## 三 操作系统内存管理基础

### 3.1 内存管理介绍

👨‍💻 **面试官**: **操作系统的内存管理主要是做什么？**

🙋 **我：** 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

### 3.2 常见的几种内存管理机制

👨‍💻 **面试官**: **操作系统的内存管理机制了解吗？内存管理有哪几种方式?**

🙋 **我：** 这个在学习操作系统的时候有了解过。

简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**。

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。

4. **段页式管理机制** ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。

### 3.3 快表和多级页表

👨‍💻**面试官** ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！

🙋 **我** ：在分页内存管理中，很重要的两点是：

1. 虚拟地址到物理地址的转换要快。
2. 解决虚拟地址空间大，页表也会很大的问题。

#### 快表

为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。

#### 多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章

- 多级页表如何节约内存：[https://www.polarxiong.com/archives/多级页表如何节约内存.htmlopen in new window](https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html)

#### 总结

为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。

### 3.4 分页机制和分段机制的共同点和区别

👨‍💻**面试官** ： **分页机制和分段机制有哪些共同点和区别呢？**

🙋 **我** ：

1. 共同点：

   - 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。
   - 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

2. 区别：

   - 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
   - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

### 3.5 逻辑(虚拟)地址和物理地址

我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。

### 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?

👨‍💻**面试官** ：**CPU 寻址了解吗?为什么需要虚拟地址空间?**

🙋 **我** ：

现代处理器使用的是一种称为 **虚拟寻址(Virtual Addressing)** 的寻址方式。**使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。** 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 **内存管理单元（Memory Management Unit, MMU）** 的硬件。**MMU 需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。**如下图所示：

**为什么要有虚拟地址空间呢？**

- 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。
- 多个程序对同一个内存操作，可能会造成前一个程序对内存的赋值被后一个进程的赋值覆盖，这就进程崩溃。

**通过虚拟地址访问内存有以下优势：**

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

**页表：**

> 仅讨论单页表，实际生产环境中是采用层次结构的页表

页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。在进行动态内存分配时，例如`malloc()`函数或者其他高级语言中的`new`关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表。

虚拟页`VP 0`、`VP 4`、`VP 6`、`VP 7`被缓存在物理内存中，虚拟页`VP 2`和`VP 5`被分配在页表中，但并没有缓存在物理内存，虚拟页`VP 1`和`VP 3`还没有被分配。

**缺页时：**

当 CPU 遇见缺页时会触发一个缺页异常，缺页异常将控制权转向操作系统内核，然后调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已被修改过，内核会先将它复制回硬盘（采用写回机制而不是直写也是为了尽量减少对硬盘的访问次数），然后再把该虚拟页覆盖到牺牲页的位置，并且更新 PTE。

当缺页异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送给 MMU\*。由于现在已经成功处理了缺页异常，所以最终结果是页命中，并得到物理地址。

## 四 虚拟内存

### 4.1 什么是虚拟内存(Virtual Memory)?

👨‍💻**面试官** ：再问你一个常识性的问题！**什么是虚拟内存(Virtual Memory)?**

🙋 **我** ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。**为什么可以这样呢？** 正是因为 **虚拟内存** 的存在，通过 **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，**虚拟内存为每个进程提供了一个连续完整的私有内存空间**。这样会更加有效地管理内存并减少出错。

**虚拟内存**是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间。

> [《虚拟内存的那点事儿》](https://juejin.im/post/59f8691b51882534af254317)

### 4.2 局部性原理

👨‍💻**面试官** ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的**局部性原理**。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。

🙋 **我** ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。

局部性原理表现在以下两个方面：

1. **时间局部性原理** ：一个被访问过的内存地址在之后会有很大几率被再次访问（由于在程序中存在着大量的循环操作）。
2. **空间局部性原理** ：一个被访问过的内存地址以及其周边的内存地址都会有很大几率被再次访问（因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的）。

如果一个程序没有良好的局部性，将会使工作集的大小不断膨胀，直至超过物理内存的大小，这时程序会产生一种叫做抖动（thrashing）的状态，页面会不断地换入换出，如此多次的读写硬盘开销，性能自然会十分“恐怖”。**所以，想要编写出性能高效的程序，首先要保证程序的时间局部性与空间局部性。**

### 4.3 虚拟内存

> ---

👨‍💻**面试官** ：讲讲虚拟内存了吧

🙋 **我** ：

> 这部分内容来自：[王道考研操作系统知识点整理](https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html)。

基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟存储器**。

实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。

> 使用了虚拟内存，就可以主存看作为 cpu 和在硬盘上的虚拟地址空间之间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。

### 4.4 虚拟内存的技术实现

👨‍💻**面试官** ：**虚拟内存技术的实现呢？**

🙋 **我** ：**虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。** 虚拟内存的实现有以下三种方式：

1. **请求分页存储管理** ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。

2. **请求分段存储管理** ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. **请求段页式存储管理**

**这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？**

请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。

它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。

不管是上面那种实现方式，我们一般都需要：

1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
2. **缺页中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；
3. **虚拟地址空间** ：逻辑地址到物理地址的变换。

### 4.5 页面置换算法

👨‍💻**面试官** ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 **页面置换算法的作用?常见的页面置换算法有哪些?**

🙋 **我** ：

> 这个题目经常作为笔试题出现

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。

> **缺页中断** 就是要访问的**页**不在内存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。
