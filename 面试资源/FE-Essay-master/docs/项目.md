# bilibili 

## 项目介绍
- 项目主要是双人合作的前后端分离的项目，主要使用vue前端框架来制作。
  使用的技术主要是 vue 全家桶 axios请求接口以及 koa 实现仿哔哩哔哩首页
为了提高团队的协作性，vue 部分采用组件化开发，Vuex 使用模块化分离 并使用 actionType进行方法名的命名与管理，后台路由模块化分离并封装接口请求。

## 图片base64化优缺点：
1. 优点：
   - base64格式的图片是文本格式，占用内存小，转换后的比例大概为1/3，降低了资源服务器的消耗；
   - 网页中使用base64格式的图片时，不用再请求服务器调用图片资源，较少了服务器请求数；
2. 缺点
   - base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力；
   - 网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。
   - base64无法缓存，要缓存只能缓存包含base64的文件，比如js或者css，这比直接缓存图片要差很多，而且一般HTML改动比较频繁，所以等同于得不到缓存效益。
3. 实际应用：
   - 一般图片小于10KB的时候，我们才会选择base64图片格式；太大的图片转换为base64得不偿失；

## 聊聊web图片的格式：gif、jpg、png、webp
1. 图片格式分类
   - 无压缩。无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP格式就是其中之一。
   - 无损压缩。压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。
   - 有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。

2. Gif
   采用LZW压缩算法进行编码，是一种无损的基于索引色的图片格式。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8=256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。
3. Jpg
   jpg是一种有损的基于直接色的图片格式。由于采用直接色，jpg可使用的颜色有1600w之多（2^24），而人眼识别的颜色数量大约只有1w多种，因此jpg非常适合色彩丰富图片、渐变色。jpg有损压缩移除肉眼无法识别的图片细节后，可以将图片的尺寸大幅度地减小。
   但是jpg不适合icon、logo，因为相比gif/png-8，它在文件大小上丝毫没有优势。

4. png-8
png-8采用无损压缩，是基于8位索引色的位图格式。png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。这也是png-8没办法完全替代gif的重要原因。如果没有动画需求推荐使用png-8来替代gif。

5. png-24
png-24采用无损压缩，是基于直接色的位图格式。png-24的图片质量堪比bmp，但是却有bmp不具备的尺寸优势。当然相比于jpg，gif，png-8，尺寸上还是要大。正是因为其高品质，无损压缩，非常适合用于源文件或需要二次编辑的图片格式的保存。
png-24与jpg一样能表达丰富的图片细节，但并不能替代jpg。图片存储为png-24比存储为jpg，文件大小至少是jpg的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用jpg。
png-24与png-8一样也支持透明。

6. `WebP图片是一种新的图像格式，由Google开发。`与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，当然目前webp的还没有得到全面的支持。
    - 对于图片的格式使用的是webp图片比PNG、JPG格式图片节约不少体积，但是兼容性不是很好。
    1. 使用canvas的toData进行判断
        - 判断方法浏览器支持webp格式方法：
        HTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。
        - toDataURL方法将图片转化为包含dataURI的DOMString，通过 base64 编码前面的图片类型值是image/webp进行判断。
        
    2. 在服务端根据请求header信息判断浏览器是否支持webp
    
    在图片请求发出的时候，Request Headers 里有 Accept，服务端可以根据Accept 里面是否有 image/webp 进行判断。

    3. 通过加载一张 webp 图片进行判断

## 懒加载
1. 什么是懒加载
`懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。`用户滚动到它们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。
2. 为什么要用懒加载
能提升用户的体验，不妨设想下，用户打开像手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。
减少无效资源的加载，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。
防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。
3. `懒加载的原理`
首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中，
当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。

## 雪碧图
   多个图片集成在一个图片中的图
   使用雪碧图可以减少网络请求的次数，加快允许的速度
   通过background-position，去定位图片在屏幕的哪个位置


## 项目难点
 - bilibili请求图片的时候，浏览器状态码403 说明已经请求成功了 但是它就不允许我拿到图片；
 一开始的话，我使用了懒加载的方式来解决问题，但是没用，问同学也不知道问题出在哪里；
 后面我就上网百度查资料，说后端有个属性referred 里面的属性值是bilibili他自己的地址，别的地址都不允许访问；然后我就在自己的项目下安装了一个vue-meta的包，在里面将meta的值设置为no-referer, 就将refer屏蔽掉了，图片也就出现了。


## 自己做的侧边栏导航
### 功能实现：
- 效果图可以看出：导航栏中的条目元素item进行拖拽，并且页面专题解构同步改变。
- 点击任意条目元素item，可以立即跳转到对应页面位置。
- 当浏览页面时，移动某个专题时，旁边的条目元素也会与之对应。
需求：简述对h5和css进行编写，重点是如何实现实时滚动导航滚动导航和拖拽。

### 获取专题名称和对应的数据
1. 到vuex里拿数据，完成显示专题名称，拖拽等功能，需要sortValue、sortKeys以及sortId，这些都是vuex通过去请求bilibili官方提供的api进行拿取。
2. 对数据进行初始化：
  - 首先我们需要将所有我们实现需求所需的数据，全部简单初始化写在data，如我们需要实现页面滚动时条目跟随专题，就需要获取这个条目的序号，名字，元素以及距离页面顶部的高度等等。要实现可以把条目进行拖拽，就需要获取是否参与拖拽状态，正在拖拽哪一个条目，所有需要获取拖拽的条目序号以及鼠标的一些数据。
  - 除此之外，必须实现兼容所有浏览器的情况下，获取整个页面的大小宽高数据以及对鼠标操作有实时的监听。

```解决因浏览器大小造成页面内元素尺寸的变化
init()：在浏览器中打开可能是全屏或者是小窗，此时页面的大小高度都会改变，我们必须每次当浏览器窗口大小变化时，重新获取（初始化），当前屏幕的高度以及每个条目元素相对窗口的位置，只有这样才可以在不同的情况下，也不出错，实时变化。使用screen.availHeight.availHeight获取屏幕高度，使用getBoundingClientRect()方法来获取条目元素相对于视窗的位置，如下图所示。
```
```数据实时监听的实现
bindEvent()：这个方法里面写了对鼠标操作以及滚动的行为进行事件绑定，也可说监听，这是实现实时变化的关键。这个方法里面我要特别说一下的是我们使用mouseleave，而不使用mouseout,的原因是我们需要实现进行拖拽时，当条目元素脱出侧边栏，这个元素将不会显示了(下面将放上展示动图)，因为触发了mouseleave，这个方法是当鼠标离开其父组件时触发。不使用mouseout是因为这个方法离开元素自己的位置就会触发离开其父级元素的时候也会触发，是冒泡触发的。这里我们使用一定要准确，如果你还是有点不理解，可以去试试MDN上的对比演示demo演示demo文档。
```
```
initData(): 将this.options.items转化成新的数组this.data,返回名字、元素本身、元素相对于其 offsetParent 元素的顶部的距离以及该元素的像素高度，高度包含该元素的垂直内边距和边框。
```
```
getOffsetTop（）：获取条目元素距离顶部的距离，这里作者不过多讲解推荐一篇文章JavaScript之scrollTop、scrollHeight、offsetTop、offsetHeight等属性学习笔记。需要讲解的是return top + scrollTop - clientTop;「元素本身的高度加上滚动增加的高度减去一个重复的上边框高度才是实际的元素的高度」。
```
3. 现在我们就要开始实现第一个功能，点击条目元素，网页移动到对应的位置，我们要实现这个功能很容易，只要获取对应条目元素的位置和index就可以实现，但是要实现平滑的滚动需要引入smooth-scroll.js
4. 实现页面滚动时条目元素跟随对应
我们使用了初始化里面的数据，然后滚动的关键就是获得元素到窗口的距离以及偏移值。需要注意的一个细节是「滚动时元素与窗口顶部的距离大于300px」时，整个组件将吸顶
5. 实现拖拽：
   - 进入排序模式
     由css的动画来实现。
   - 开始拖拽
     开始拖拽时，需要判断是否进入了排序，进入了才允许可以进行拖拽，此时获得鼠标选中的位置，元素的位置以及对应id。
   - 拖拽中
     进入拖拽时，首要的是判断是否获取了要拖拽元素的鼠标位置，如果没有获取到，将无法进行拖拽，则使用e.preventDefault()通知浏览器不进行拖拽。然后使用dragStyles()获取元素拖拽的实时位置。最后元素拖拽时会改变其他元素的位置，位置改变了，其对应的id就会发生变化，我们通过replaceItem()来实现，在这个方法里面，我们奇妙的利用「元素的实时高度与元素本身的高度相除获得动态的id」。
   - 拖拽完成
     这段代码巧妙的是，首先判断是否还在进行拖拽如果有，则this.isDrag = false;停止拖拽，接着就是核心部分巧妙利用splice,如果this.replaceItem !== this.dragId,则在this.replaceItem后面添加this.options.items.splice(this.dragId, 1)[0],即这个拖拽元素初始id,相当于拖拽不成功，回到原来的位置，否则拖拽成功。下面我用动图来演示一下。










# DP后台可视化项目
## 项目描述
    1) 此项目为一个前后台分离的后台管理的 SPA,
    2)包括用户管理 / 商品分类管理 / 商品管理 / 权限管理等功能模块 
    3) 前端: 使用 React 全家桶 + Antd + Axios + ES6 + Webpack 等技术 
    4) 后端: 使用 Node + Express + Mongodb 等技术 
    5) 采用模块化、组件化、工程化的模式开发
## 优化
   - 使用antd组件，组件按需打包减少项目体积
   - 引入需要的js.css文件 
# 登录界面
## 登录流程
1. 对输入的账号密码进行校验，校验合法，再对用户名和密码进行加密的情况下则进行登录请求。
2. 进行请求登录接口的时候会校验用户名是否存在如果不存在返回用户名不存在，请注册；若存在则校验用户名和密码是否正确，如果正确，就返回登录成功的验证码，并返回登录成功和加密的token，（我的是由一个加密字段+加密的用户名+token的有效期组成）。如果错误，则返回错误的状态码和账号或密码错误。
3. 前端拿到后端的返回值如果登录成功，就会用window.localStorage.setItem('token', result.token)保存在本地，并且跳转到首页。
4. 如何判断是登录状态，
我们用axios去对http进行全局拦截，并把token放在头部，每次请求有返回的都是先经过拦截器的。如果登陆过期，需要重新登陆并清空vuex/redux和localstorage 的token，而且会跳转到login页面。

判断是否是登录状态就是当我们进行请求或者页面刷新的时候，请求返回时在header带上token和本地的token进行比较如果相同则处于登录状态，如果不同则进行跳转到重新登录。

## 按需引入优化：
首先的话是去浏览了antd官方文档
然后我再对react-app脚手架配置进行改写 -> 安装了react-app-rewried包 
并且在script里面修改为rewired
在安装一些babel-loader babel-plugin等等的插件
根据文档参考得到配置文件：进行复制了config-overrides.js组件按需引入的配置文件；
配置babel-loader、babel-plugin的文件
配置完之后就可以在组件页面用import单个组件引入而不是把整个antd包引入进来，这样性能会更好，需要用什么引入什么



我在有赞主要负责支付运营平台，对账平台，资损防控平台，微商城商家后台和高汇通官网。

支付运营平台，是一个公司的跟支付有关的综合运营平台 主要给财务等职能部门使用，是中台化的项目，主要技术栈是react。

对账平台和资损防控系统与支付运营平台类似，只是功能有所不同。

微商城商家后台，是一个公司主要业务的商家后台，商家可以进行各项操作，采用微前端架构，各个应用模块统一接入中台，我当时主要负责发票业务，主要技术栈react。



